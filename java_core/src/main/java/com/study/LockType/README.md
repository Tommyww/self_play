转自原文：http://www.yidianzixun.com/n/0DGEYKbO?s=9&appid=xiaomi&ver=3.6.2&utk=0fqa2h4w

最近在工作上碰见了一些高并发的场景需要加锁来保证业务逻辑的正确性，并且要求加锁后性能不能受到太大的影响。
初步的想法是通过数据的时间戳，id等关键字来加锁，从而保证不同类型数据处理的并发性。
而java自身api提供的锁粒度太大，很难同时满足这些需求，于是自己动手写了几个简单的扩展...

1. 分段锁

借鉴concurrentHashMap的分段思想，先生成一定数量的锁，具体使用的时候再根据key来返回对应的lock。这是几个实现里最简单，性能最高，也是最终被采用的锁策略。
分段锁，系统提供一定数量的原始锁，根据传入对象的哈希值获取对应的锁并加锁
注意：要锁的对象的哈希值如果发生改变，有可能导致锁无法成功释放  class SegmentLock
2. 哈希锁

上述分段锁的基础上发展起来的第二种锁策略，目的是实现真正意义上的细粒度锁。每个哈希值不同的对象都能获得自己独立的锁。
在测试中，在被锁住的代码执行速度飞快的情况下，效率比分段锁慢 30% 左右。如果有长耗时操作，感觉表现应该会更好。代码如下：
class HashLock
3. 弱引用锁

哈希锁因为引入的分段锁来保证锁创建和销毁的同步，总感觉有点瑕疵，所以写了第三个锁来寻求更好的性能和更细粒度的锁。这个锁的思想是借助java的弱引用来创建锁，把锁的销毁交给jvm的垃圾回收，来避免额外的消耗。
有点遗憾的是因为使用了ConcurrentHashMap作为锁的容器，所以没能真正意义上的摆脱分段锁。这个锁的性能比 HashLock 快10% 左右。锁代码：
/** * 弱引用锁，为每个独立的哈希值提供独立的锁功能 */  class WeakHashLock<T>

后记

最开始想借助 locksupport 和 AQS 来实现细粒度锁，写着写着发现正在实现的东西和java 原生的锁区别不大，于是放弃改为对java自带锁的封装，浪费了不少时间。
实际上在实现了这些细粒度锁之后，又有了新的想法，比如可以通过分段思想将数据提交给专门的线程来处理，可以减少大量线程的阻塞时间，留待日后探索...
